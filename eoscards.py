#!/usr/bin/python3

'''
This program is a command line text game that challenges the user on
their knowledge of ETC Eos terminology.

@TODOS:
* weight answers for user comfort/difficulty
* add timer on response to gauge how well user remembers
* add GUI
* calling list() a lot when genrating answers, would be better for runtime
    to store all values at beginning?
*X - completed - change ask_q to be numbers to avoid str coersion
* add try block for input validation in ask_q()
'''

import random
import time
import os

# dictionary of {terms:defintions}
EOSDICT = {'go': 'execute a cue',
           'stop': 'pause a cue',
           'back': 'restore previous cue',
           'address': 'the digital location of an instrument',
           'query': 'grep patch',
           'snapshot': 'a preset for screen layouts',
           'submaster': 'not a fader',
           'fader': 'a playback for cuelists and other record targets',
           'load': 'prepare a cue in the Go button for next keypress',
           'palette': 'a recorded data object specific to a parameter type',
           'preset': 'a non specific data object, may contain palettes',
           'order 66': 'shutdown macro',
           'macro': 'recorded commands replayed on a single keypress'}

ANS_LIST = ['order 66', 'address', 'go']


def main():
    memory()
    play_again()

# memory cards


def memory():
    past = []
    correct = 0
    # while len(past) < len(EOSDICT):
    while len(past) < len(ANS_LIST):
        past = game(past, correct)
    # print(f"Wow, you got {correct} out of {len(past)}!!\n")


def game(answered, correct):
    time.sleep(1)
    os.system('clear')
    ans = get_ans(answered, EOSDICT)
    #print(f'answer = {ans}')
    defs = get_anspad(ans)
    #print([i for i in defs])
    defs = shuffle(defs, ans)
    respond = ask_q(ans, defs)
    if verify(ans, respond):
        answered.append(ans)
        correct += 1
    return answered

# def get_ans():


def get_ans(answered, EOSDICT):
    '''
    DOCSTRING: This function takes in a list answered and a dictionaey
    EOSDICT. It selects a random entry from the dictionary and compares
    against the previous answers in the answered list.
    '''
    answer = ""
    while True:
        # answer = pick random entry
        # answer = random.choice(list(EOSDICT.keys()))
        answer = random.choice(ANS_LIST)
        # compare answer against previous game answer
        if answer not in answered:
            break
    return answer


def get_anspad(answer):
    '''
    DOCSTRING: This function takes in the answer generated by get_ans(),
    pulls 3 additional definitions from EOSDICT, and compares them to
    confirm there are no duplicates.
    Returns a list "anspad" to be shuffled and printed
    '''
    # pick 3 additional defs that aren't answer
    anspad = []
    for _ in range(3):
        tmpans = EOSDICT[answer]
        while tmpans == EOSDICT[answer]:
            tmpans = random.choice(list(EOSDICT.values()))
        anspad.append(tmpans)
    return anspad

# shuffle answers


def shuffle(anspad, answer):
    '''
    DOCSTRING: This function takes in the list of defintions generated by
    get_anspad, shuffles them, and returns new list.
    '''
    anspad.append(EOSDICT[answer])
    random.shuffle(anspad)
    return anspad

# display question and answers


def ask_q(answer, anspad):
    '''
    DOCSTRING: This function takes in the answer and definitions, prints
    them, queries the user, and returns their the string definition
    the user chose.
    '''
    print(f"What is the definition of {answer}?\n")
    print(
        f"1) {anspad[0]}\n2) {anspad[1]}\n3) {anspad[2]}\n4) {anspad[3]}\n\n")
    print("Answer: ")
    # add input verification
    response = int(input('>')) - 1
    return anspad[response]

# receive and verify user input


def verify(answer, response):
    '''
    DOCSTRING: This function takes in the generated answer and the
    user's response, compares them, and prints the result. Returns
    True if correct, False if incorrect.
    '''
    result = EOSDICT[answer] == response
    if result:
        print("\n\n     Congrats! Nailed it!\n\n")
        return True
    else:
        print("\n\n     Sorry, incorrect.\n\n")
        return False


def play_again():
    '''
    DOCSTRING: This function asks the user if they want to play again
    if yes, restart memory, if no then exit.
    '''
    print("Would you like to play again?")
    print("Enter 'y' or 'n'")
    if input('>')[0].lower() != 'n':
        memory()

# log scores and track user
# time user resonse, divide response_time by length of definitions
# weight terms in user_dict based on response_time
#class USER():
#    def __init__(self, name):
#        self.name = name
#        self.answered = USER_DICT(EOSDICT)

#when user created check dicionary for existing terms
#create user_dict with term, deinition, and user_score
class USER():
    def __init__(self, name, shared_dict):
        self.name = name
        self.shared_dict = shared_dict
        for i in shared_dict:
            #create empty dict for each term in game
            self.i = {}
            #add defintions with key 'def'
            self.i['def'] = shared_dict[i]
            self.i.times_answeered = 0
            self.i.avg_time = 0

    def __str__(self):
        return self.name
    def get_response_time(self):
        pass

if __name__ == '__main__':
    main()



####################
# console geography
