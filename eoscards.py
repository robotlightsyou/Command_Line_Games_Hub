#!/usr/bin/python3
#cat this file

'''
This program is a command line text game that challenges the user on
their knowledge of ETC Eos terminology.

@TODOS:
* weight answers for user comfort/difficulty
* add timer on response to gauge how well user remembers
* add GUI
* calling list() a lot when genrating answers, would be better for runtime
    to store all values at beginning?
*X - completed - change ask_q to be numbers to avoid str coersion
* add try block for input validation in ask_q()
* add fake answer check to avoid repeats

Object inheritance is failing, research how to make objects
sub-object(?) instances nb USER.(variable).attribute

'''

import random
import time
import os
from pprint import pprint

# dictionary of {terms:defintions}
EOSDICT = {'go': 'execute a cue',
           'stop': 'pause a cue',
           'back': 'restore previous cue',
           'address': 'the digital location of an instrument',
           'query': 'grep patch',
           'snapshot': 'a preset for screen layouts',
           'submaster': 'not a fader',
           'fader': 'a playback for cuelists and other record targets',
           'load': 'prepare a cue in the Go button for next keypress',
           'palette': 'a recorded data object specific to a parameter type',
           'preset': 'a non specific data object, may contain palettes',
           'order 66': 'shutdown macro',
           'macro': 'recorded commands replayed on a single keypress'}

ANS_LIST = ['order 66', 'address', 'go']

# obj = someobject
# obj.a = SimpleNamespace()
# for p in params:
#     setattr(obj.a, p, value)
# # obj.a.attr1


class USER():
    def __init__(self, shared_dict):
        # def __init__(self, name, shared_dict):
        #self.name = name
        self.shared_dict = shared_dict
        for i in self.shared_dict.keys():
            # create empty dict for each term in game
            self.i = {}
            #self.i = Term(i, shared_dict)
            # add defintions with key 'def'
            self.i["def"] = self.shared_dict[i]
            self.i["times_answeered"] = 0
            self.i["avg_time"] = 0
            self.i["cum_time"] = 0

    def update_time(self, start_time, end_time, answer):
        ans_time = end_time - start_time
        getattr(self, answer)["times_answeered"] += 1
        getattr(self, answer)["cum_time"] += ans_time
        #self.answer["cum_time"] += ans_time
        getattr(self, answer)["avg_time"] = getattr(self, answer)[
            "cum_time"] / getattr(self, answer)["times_answeered"]
        print('Avg time = {}'.format(getattr(self, answer)['avg_time']))


def main():
    p = USER(EOSDICT)
    pprint(vars(p))

#print("Who is playing? ")
#player = input('>')
# player = USER(EOSDICT)
# memory(player)
# #memory()
# play_again(player)

# memory cards


def memory(user):
    past = []
    correct = 0
    timer = time.time()
    # while len(past) < len(EOSDICT):
    while len(past) < len(ANS_LIST):
        past = game(past, correct, user)
        if time.time() - 30 > timer:
            print("Time's up.")
            break

    # print(f"Wow, you got {correct} out of {len(past)}!!\n")


def game(answered, correct, user):
    time.sleep(1)
    os.system('clear')
    ans = get_ans(answered, EOSDICT)
    #print(f'answer = {ans}')
    defs = get_anspad(ans)
    #print([i for i in defs])
    defs = shuffle(defs, ans)
    respond = ask_q(ans, defs, user)
    if verify(ans, respond):
        answered.append(ans)
        correct += 1
    return answered

# def get_ans():


def get_ans(answered, EOSDICT):
    '''
    DOCSTRING: This function takes in a list answered and a dictionaey
    EOSDICT. It selects a random entry from the dictionary and compares
    against the previous answers in the answered list.
    '''
    answer = ""
    while True:
        # answer = pick random entry
        # answer = random.choice(list(EOSDICT.keys()))
        answer = random.choice(ANS_LIST)
        # compare answer against previous game answer
        if answer not in answered:
            break
    return answer


def get_anspad(answer):
    '''
    DOCSTRING: This function takes in the answer generated by get_ans(),
    pulls 3 additional definitions from EOSDICT, and compares them to
    confirm there are no duplicates.
    Returns a list "anspad" to be shuffled and printed
    '''
    # pick 3 additional defs that aren't answer
    anspad = []
    for _ in range(3):
        tmpans = EOSDICT[answer]
        while tmpans == EOSDICT[answer]:
            tmpans = random.choice(list(EOSDICT.values()))
        anspad.append(tmpans)
    return anspad

# shuffle answers


def shuffle(anspad, answer):
    '''
    DOCSTRING: This function takes in the list of defintions generated by
    get_anspad, shuffles them, and returns new list.
    '''
    anspad.append(EOSDICT[answer])
    random.shuffle(anspad)
    return anspad

# display question and answers


def ask_q(answer, anspad, user):
    '''
    DOCSTRING: This function takes in the answer and definitions, prints
    them, queries the user, and returns their the string definition
    the user chose.
    '''
    start_time = time.time()
    #print(f"What is the definition of {answer}?\n")
    print("What is the definition of {}?\n".format(answer))
    print("1) {}\n2) {}\n3) {}\n4) {}\n\n".format(
        anspad[0], anspad[1], anspad[2], anspad[3]))
#        f"1) {anspad[0]}\n2) {anspad[1]}\n3) {anspad[2]}\n4) {anspad[3]}\n\n")
    print("Answer: ")
    # add input verification
    response = int(input('>')) - 1
    end_time = time.time()
    user.update_time(start_time, end_time, answer)
    return anspad[response]

# receive and verify user input


def verify(answer, response):
    '''
    DOCSTRING: This function takes in the generated answer and the
    user's response, compares them, and prints the result. Returns
    True if correct, False if incorrect.
    '''
    result = EOSDICT[answer] == response
    if result:
        print("\n\n     Congrats! Nailed it!\n\n")
        return True
    else:
        print("\n\n     Sorry, incorrect.\n\n")
        return False


def play_again(user):
    '''
    DOCSTRING: This function asks the user if they want to play again
    if yes, restart memory, if no then exit.
    '''
    print("Would you like to play again?")
    print("Enter 'y' or 'n'")
    if input('>')[0].lower() != 'n':
        memory(user)


class Term():
    def __init__(self, name, shared_dict):
        self.name = name
        self.defi = shared_dict[name]
        self.times_answeered = 0
        self.avg_time = 0
        self.cum_time = 0

    def update_time(self, start_time, end_time, answer):
        ans_time = end_time - start_time
        self.times_answeered += 1
        self.cum_time += ans_time
        self.avg_time = self.cum_time / self.times_answeered

    def __str__(self):
        return self.name


class USER():
    def __init__(self, shared_dict):
        # def __init__(self, name, shared_dict):
        #self.name = name
        self.shared_dict = shared_dict
        for i in shared_dict:
            # create empty dict for each term in game
            self.i = {}
            #self.i = Term(i, shared_dict)
            # add defintions with key 'def'
            self.i["def"] = shared_dict[i]
            self.i["times_answeered"] = 0
            self.i["avg_time"] = 0
            self.i["cum_time"] = 0

    def update_time(self, start_time, end_time, answer):
        ans_time = end_time - start_time
        getattr(self, answer)["times_answeered"] += 1
        getattr(self, answer)["cum_time"] += ans_time
        #self.answer["cum_time"] += ans_time
        getattr(self, answer)["avg_time"] = getattr(self, answer)[
            "cum_time"] / getattr(self, answer)["times_answeered"]
        print('Avg time = {}'.format(getattr(self, answer)['avg_time']))

    def __str__(self):
        return self.name


if __name__ == '__main__':
    main()


# log scores and track user

####################
# console geography
