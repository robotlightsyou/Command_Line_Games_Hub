#!/usr/bin/python3

"""
This program runs a basic memory card game. If memory() is
called for the menu it will take arguments, but if the program
is runa s main the user will still be prompted for input.

Input:
User: user, who is playing the game.
dictionary: deck - a dictionary of terms and definitions
integer: tlimit  - the time limit in seconds for the game
Output:
list: cards_played - a list of strings representing the card names
from te most recent round
User: user - an update User instance
"""

import random
import time
import os
import shelve
import menu as mu
import dicts
import utils


def memory(user, deck):
    """
    Run the full game sequence one time.

    Input:
    user -- User
    deck -- dictionary -the terms the player is being quizzed on
    Output:
    game_cards -- List
    user -- the updated User object.
    """
    # past is a list of all cards played in session
    past = set()
    correct = 0
    tlimit = how_long()
    timer = time.time()
    while len(past) < len(deck):
        past |= one_round(past, correct, user, deck)
        # add 1 second to account for displaying results
        timer += 1
        if time.time() - tlimit > timer:
            print("Time's up.")
            print()
            break
    return past, user


def one_round(answered, correct, user, deck):
    """
    Ask, answer, and update one Term.

    This function draws a card from the game deck, selects filler
    answers for multiple choice, queries the user, verifies the answer, updates
    the user stats, and returns an updated deck. If user is correct card is
    removed from the draw deck, if incorrect card may appear again in round.

    Input:
    set -- answered --  a list of terms already correctly answered in game
    integer -- correct --  an integer representing total correct in game
    User -- user  -- the profile to receive stats update
    Output:
    set: answered  -- a list of correctly answered terms in this individual game.
    """
    time.sleep(1)
    os.system('clear')
    ans = get_answer(answered, deck, user)
    defs = get_wrong_answers(ans, deck)
    defs = shuffle(defs, ans, deck)
    respond = ask_question(ans, defs, user, deck)
    if verify(ans, respond, deck):
        answered.add(ans)
        correct += 1
        user.memory[deck['__dict_name__']][ans].update_correct()
    return answered


def get_answer(answered, deck, user):
    """
    Select an unused Term from deck.

    Input:
    answered -- a set of previous Terms to ensure no repeats
    deck: deck name
    user -- the User instance
    Output:
    answer -- a string of the Term's name
    """
    keys_list = list(deck.keys())
    prob_list = [user.memory[deck['__dict_name__']][i].weight for i in keys_list]
    answer = ""
    while True:
        answer = random.choices(keys_list, weights= prob_list, k = 1)
        # answer = random.choices(keys_list, cum_weights= prob_list, k = 1)
        # compare answer against previous game answer
        if answer[0] not in answered:
            if answer[0] != '__dict_name__':
                print(answer)
                break
    return answer[0]


def how_long():
    """
    Set the time limit on the individual rounds of the game.

    Output:
    time -- integer number of seconds for the round to last.
    """
    # os.system('clear')
    print('Enter how long you would like the round to last in seconds.')
    print('Minimum is 30 seconds, max is 120.\n')
    time = input(">")
    print()
    try:
        time = int(time)
        if 30 <= time <= 120:
            return time
        else:
            print("please enter digits between 30-120")
            return how_long()
    except ValueError:
        print("please enter digits between 30-120")
        return how_long()


def get_wrong_answers(answer, deck):
    """
    Get 3 incorrect answers from deck for multiple choice.

    This function takes in the answer generated by get_ans(),
    pulls 3 additional definitions from deck, and compares them to
    confirm there are no duplicates.
    Returns a list "anspad" to be shuffled and printed

    Input:
    string: answer
    Output:
    list: anspad --> the 3 incorrect answers
    """
    anspad = []
    while len(anspad) < 3:
        tmpans = deck[answer]
        while tmpans == deck[answer]:
            tmpans = random.choice(list(deck.values()))
        if tmpans not in anspad:
            if tmpans != deck['__dict_name__']:
                anspad.append(tmpans)
    return anspad


def shuffle(wrong_answers, answer, deck):
    """
    Insert answer to padding then shuffle.

    This function takes in the list of defintions generated by
    get_wrong_answers, adds the correct answer, shuffles them, and returns
    a new list.

    Input:
    list of strings: anspad
    string: answer
    """
    answer_options = []
    answer_options.extend(wrong_answers)
    answer_options.append(deck[answer])
    random.shuffle(answer_options)
    return answer_options


def ask_question(answer, anspad, user, deck):
    """
    Ask question and take in user response.

    This function takes in the answer and definitions, prints
    them, queries the user, and returns their the string definition
    the user chose.

    Input:
    string: answer
    list of strings: andpad
    User: user
    Output:
    string: anspad[response]
    """
    start_time = time.time()
    print(f"What is the definition of {answer}?\n")
    print(
        f"1) {anspad[0]}\n2) {anspad[1]}\n3) {anspad[2]}\n4) {anspad[3]}\n\n")
    print("Answer: ")
    response = utils.valifate_response(anspad)
    end_time = time.time()
    defs_length = sum([len(i) for i in anspad])
    user.memory[deck['__dict_name__']][answer].update_time(
        start_time, end_time)
    user.memory[deck['__dict_name__']][answer].update_weight(defs_length)
    return anspad[response]


def verify(answer, response, deck):
    """
    Check the user response against actual anser.

    This function takes in the generated answer and the
    user's response, compares them, and prints the result. Returns
    True if correct, False if incorrect.

    Input:
    string: answer, response
    Output:
    boolean
    """
    result = deck[answer] == response
    if result:
        print("\n\n     Congrats! Nailed it!\n\n")
        return True
    else:
        print("\n\n     Sorry, incorrect.\n\n")
        return False


def m_play_again(user, deck):
    """
    Ask user to play again, then restart or quit.

    This function asks the user if they want to play again
    if yes, restart memory, if no then exit. Name is such to distinguish
    from play_again normally run through menu.py.

    Input:
    User: user
    Output:
    No output, but can restart the game
    """
    print(f"{user.name},\n\tWould you like to play again?")
    print("Enter 'y' or 'n'")
    if input('>')[0].lower() != 'n':
        memory(user, deck)


if __name__ == '__main__':
    # user = mu.get_player()
    user = utils.User('Player')
    deck_prompt = "What deck would you like to play?"
    deck = utils.choose_list(utils.DECKLIST, deck_prompt)
    os.system('clear')
    memory(user, deck)
    m_play_again(user, deck)
